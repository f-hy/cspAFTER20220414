//v3.0
#include <bits/stdc++.h>
using namespace std;
#define mem(f, v) memset(f,v,sizeof(f))
#define file(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);

//int supp;int todo;

typedef long long ll;
const int maxn = 5e3+3;
const int inf = ~(1u << 31u);
const ll linf = ~(1llu << 63u);
int n;//1,n,5e3
struct cursor{
    int x;
    int y;
    cursor(int _x=1,int _y=1):x(_x),y(_y){}
}cs;
struct noteBook{
    deque<string> notes;
    noteBook(){notes.push_back("\n");}
    int lineLen(int _x=cs.x){return notes.at(_x-1).size();}
    void _ini(deque<string> _notes){
        notes.clear();
        for(auto &x:_notes) notes.push_back(x);
    }
}note;
void noteInfo(){
    cout<<"--"<<note.notes.size()<<'('<<cs.x<<','<<cs.y<<')'<<"-- ";
    int i=0;
    for(auto &x:note.notes){
        cout<<'-'<<++i<<'.'<<x.size()<<'.'<<x.substr(0,x.size()-1)<<' ';
    }
    cout<<endl;
}
struct shiftOthers{
    deque<string> clipBoard;//粘贴板
    bool shift;//粘滞功能
    bool selected;//选中状态
    cursor recordPoint;//记录点
    pair<cursor,cursor> selectArea;//leftCursor, rightCursor
    shiftOthers(bool _shift=false):shift(_shift){}
    void turnArea(){//
        if(recordPoint.x==cs.x){//一行之内
            selectArea.first.x=recordPoint.x;
            selectArea.second.x=recordPoint.x;
            selectArea.first.y=recordPoint.y<cs.y?recordPoint.y:cs.y;
            selectArea.second.y=recordPoint.y>cs.y?recordPoint.y:cs.y;
        }else{
            if(recordPoint.x<cs.x){
                selectArea.first.x=recordPoint.x;
                selectArea.second.x=cs.x;
                selectArea.first.y=recordPoint.y;
                selectArea.second.y=cs.y;
            }else{
                selectArea.first.x=cs.x;
                selectArea.second.x=recordPoint.x;
                selectArea.first.y=cs.y;
                selectArea.second.y=recordPoint.y;
            }
        }
    }
}so;
void paste(){
    int dx=0;int resy=cs.y;
    note.notes.at(cs.x-1).insert(cs.y-1,so.clipBoard.front());//head line
    cs.y+=so.clipBoard.front().size();
    if(so.clipBoard.front()[so.clipBoard.front().size()-1]=='\n'){//head line is like "___\n"
        string tail;++dx;
        if(so.clipBoard.back()[so.clipBoard.back().size()-1]=='\n'){//tail line is like "___\n"
            tail=note.notes.at(cs.x-1).substr(cs.y-1,note.lineLen()-cs.y+1);++dx;resy=1;
        }else{
            tail=so.clipBoard.back()+note.notes.at(cs.x-1).substr(cs.y-1,note.lineLen()-cs.y+1);resy=so.clipBoard.back().size()+1;
        }
        note.notes.at(cs.x-1).erase(cs.y-1);
        //note.notes.at(cs.x-1)+="\n";
        //tail line
        if(cs.x==note.notes.size()){//end of the notes
            note.notes.push_back(tail);
        }else{
            note.notes.insert(note.notes.begin()+cs.x,tail);
        }
    }
    if(so.clipBoard.size()>1){//middle lines
        if(so.clipBoard.back()[so.clipBoard.back().size()-1]=='\n'){
            note.notes.insert(note.notes.begin()+cs.x,so.clipBoard.back());
        }
        for(int i=so.clipBoard.size()-2;i>0;--i){
            note.notes.insert(note.notes.begin()+cs.x,so.clipBoard.at(i));
        }
    }
    cs.x+=dx+so.clipBoard.size()-2;cs.y=resy;
}
void opmove(string op){
    if(so.selected){
        so.selected=false;
    }
    if(op=="Home"){
        cs.y=1;
    }else if(op=="End"){
        cs.y=note.lineLen();
    }else if(op=="Up"){
        if(cs.x>1){
            int tmp=note.lineLen(--cs.x);
            if(cs.y>tmp){
                cs.y=tmp;
            }
        }
    }else if(op=="Down"){
        if(cs.x<note.notes.size()){
            int tmp=note.lineLen(++cs.x);
            if(cs.y>tmp){
                cs.y=tmp;
            }
        }
    }else if(op=="Left"){
        if(cs.y>1){
            --cs.y;
        }else if(cs.x>1){
            cs.y=note.lineLen(--cs.x);
        }
    }else if(op=="Right"){
        if(cs.y<note.lineLen()){
            ++cs.y;
        }else if(cs.x<note.notes.size()){
            cs.y=1;
            ++cs.x;
        }
    }
}
void opinsert(string op){
    if(so.selected){
        so.selected=false;
        int lx=so.selectArea.first.x,
            ly=so.selectArea.first.y,
            rx=so.selectArea.second.x,
            ry=so.selectArea.second.y;
        if(lx==rx&&so.clipBoard.front()[so.clipBoard.front().size()-1]=='\n'){
            note.notes.at(lx-1).erase(ly,ry-ly);
        }else{
            note.notes.at(lx-1).erase(ly);
            note.notes.at(lx-1)+=note.notes.at(lx);//end of notes?
            todo;
            //当前 处于选中状态 时，对于不同的情况，需要按照序号依次执行以下操作：
        }
    }
    if(op=="Char"){
        string c;
        cin>>c;
        note.notes.at(cs.x-1).insert(cs.y-1,c);
        ++cs.y;
    }else if(op=="Enter"){
        if(cs.y==note.lineLen()){//行末
            if(cs.x==note.notes.size()){//末列
                note.notes.push_back("\n");
            }else{
                note.notes.insert(note.notes.begin()+cs.x,"\n");
            }
        }else if(cs.y==1){//行首
            note.notes.insert(note.notes.begin()+cs.x-1,"\n");
        }else{//行中间
            string tail=note.notes.at(cs.x-1).substr(cs.y-1,note.notes.at(cs.x-1).size()-cs.y+1);
            note.notes.at(cs.x-1).erase(cs.y-1);
            note.notes.at(cs.x-1)+="\n";
            //note.notes.at(cs.x-1).insert(cs.y,"\n");
            if(cs.x==note.notes.size()){//末列
                note.notes.push_back(tail);
            }else{
                note.notes.insert(note.notes.begin()+cs.x,tail);
            }
        }
        ++cs.x;
        cs.y=1;
    }else if(op=="Space"){
        note.notes.at(cs.x-1).insert(cs.y-1," ");
        ++cs.y;
    }else if(op=="Paste"){
        paste();
    }
}
void opremove(string op){
    if(op=="Del"){
        if(cs.x<note.notes.size()||cs.y<note.lineLen()){//不是notes末尾
            if(cs.y==note.lineLen()){//删的是换行符
                note.notes.at(cs.x-1).erase(note.lineLen()-1,1);
                note.notes.at(cs.x-1)+=note.notes.at(cs.x);
                note.notes.erase(note.notes.begin()+cs.x);
            }else{
                note.notes.at(cs.x-1).erase(cs.y-1,1);
            }
        }
    }else if(op=="Backspace"){
        if(cs.x>1||cs.y>1){//不是notes开头
            if(cs.y==1){//行头
                cs.y=note.lineLen(cs.x-1);
                note.notes.at(cs.x-2).erase(note.lineLen(cs.x-1)-1,1);//删'\n'
                note.notes.at(cs.x-2)+=note.notes.at(cs.x-1);
                note.notes.erase(note.notes.begin()+cs.x-1);
                --cs.x;
            }else{
                note.notes.at(cs.x-1).erase(cs.y-2,1);
                --cs.y;
            }
        }
    }
}
void opshift(){
    if(so.shift){//粘滞功能关闭时
        if(so.recordPoint.x!=cs.x||so.recordPoint.y!=cs.y){//此时的光标位置与记录点的位置不同，进入选中状态
            so.turnArea();
            so.selected=true;
        }
        so.shift=false;
    }else{//粘滞功能启动时
        so.recordPoint=cs;
        so.shift=true;
    }
}
ll cntWord(string word,bool global=true){
    int wordSize=word.size();
    ll res=0;
    int tmpi,tmpj;
    if(global){
        for(auto &x:note.notes){
            tmpi=x.size()-wordSize;
            for(int i=0;i<tmpi;++i){
                if(word==x.substr(i,wordSize)){
                    ++res;
                }
            }
        }
    }else{
        int lx=so.selectArea.first.x,
            ly=so.selectArea.first.y,
            rx=so.selectArea.second.x,
            ry=so.selectArea.second.y;
        if(lx+1<rx){
            tmpi=rx-1;
            for(int i=lx;i<tmpi;++i){
                tmpj=note.notes.at(i).size()-wordSize;
                for(int j=0;j<tmpj;++j){
                    if(word==note.notes.at(i).substr(j,wordSize)){
                        ++res;
                    }
                }
            }
        }
        if(note.notes.at(lx-1).size()-ly+1>=wordSize){
            tmpj=note.notes.at(lx-1).size()-wordSize;
            for(int j=ly-1;j<tmpj;++j){
                if(word==note.notes.at(lx-1).substr(j,wordSize)){
                    ++res;
                }
            }
        }
        if(ry>wordSize){
            tmpj=note.notes.at(rx-1).size()-wordSize;
            for(int j=ry-1;j<tmpj;++j){
                if(word==note.notes.at(rx-1).substr(j,wordSize)){
                    ++res;
                }
            }
        }
    }
    return res;
}
void opfind(string word){
    if(so.selected){//当前处于选中状态
        cout<<cntWord(word,false)<<'\n';
    }else{
        cout<<cntWord(word)<<'\n';
    }
}
ll cntChs(bool global=true){
    ll res=0;
    int l=32,r=127;//(l,r)
    int tmpi,tmpj;
    if(global){
        for(auto &x:note.notes){
            for(int i=0;i<x.size()-1;++i){
                if(x[i]>l&&x[i]<r){
                    ++res;
                }
            }
        }
    }else{
        //todo;
        int lx=so.selectArea.first.x,
            ly=so.selectArea.first.y,
            rx=so.selectArea.second.x,
            ry=so.selectArea.second.y;
        if(lx+1<rx){
            for(int i=lx;i<rx-1;++i){
                for(int j=0;j<note.notes.at(i).size()-1;++j){
                    if(note.notes.at(i)[j]>l&&note.notes.at(i)[j]<r){
                        ++res;
                    }
                }
            }
        }
        int i=lx-1;
        if(note.notes.at(i).size()-ly>0){
            tmpj=note.notes.at(i).size()-1;
            for(int j=ly-1;j<tmpj;++j){
                if(note.notes.at(i)[j]>l&&note.notes.at(i)[j]<r){
                    ++res;
                }
            }
        }
        i=rx-1;
        if(ry>1){
            tmpj=note.notes.at(i).size()-1;
            for(int j=ry-1;j<tmpj;++j){
                if(note.notes.at(i)[j]>l&&note.notes.at(i)[j]<r){
                    ++res;
                }
            }
        }
    }
    return res;
}
void opcount(){
    if(so.selected){
        cout<<cntChs(false)<<'\n';
    }else{
        cout<<cntChs()<<'\n';
    }
}
void opcopy(){
    int lx=so.selectArea.first.x,
        ly=so.selectArea.first.y,
        rx=so.selectArea.second.x,
        ry=so.selectArea.second.y;
    if(so.selected){
        so.clipBoard.clear();
        if(lx==rx){//一行之内
            so.clipBoard.push_back(note.notes.at(lx-1).substr(ly-1,ry-ly));
        }else{//超过一行
            so.clipBoard.push_back(note.notes.at(lx-1).substr(ly-1,note.notes.at(lx-1).size()-ly+1));//Head
            if(lx+1<rx){//超过2行
                for(int i=lx;i<rx-1;++i){
                    so.clipBoard.push_back(note.notes.at(i));
                }
            }
            so.clipBoard.push_back(note.notes.at(rx-1).substr(0,ry-1));//Tail
        }
    }else{
        int lineLen=note.lineLen();
        if(lineLen>1){
            so.clipBoard.clear();
            so.clipBoard.push_back(note.notes.at(cs.x-1));
        }
    }
}
void opprint(){
    for(auto &x:note.notes){
        cout<<x;
    }
}

void chOp(string op){
    string s;
    if(op=="MOVE"){
        cin>>s;
        opmove(s);
    }else if(op=="INSERT"){
        cin>>s;
        opinsert(s);
    }else if(op=="REMOVE"){
        cin>>s;
        opremove(s);
    }else if(op=="SHIFT"){
        opshift();
    }else if(op=="FIND"){
        cin>>s;
        opfind(s);
    }else if(op=="COUNT"){
        opcount();
    }else if(op=="COPY"){
        opcopy();
    }else if(op=="PRINT"){
        opprint();
    }
}
/*
int main(){
    file(datat);
    deque<string> ds;
    ds.push_back("0123456789\n");
    ds.push_back("ab\n");
    ds.push_back("qwertyuiop\n");
    ds.push_back("asdfghjkl;\n");
    ds.push_back("zxcvbnm,./\n");
    note._ini(ds);
    cs.x=1,cs.y=3;
    opshift();
    noteInfo();
    cs.x=3,cs.y=5;
    opshift();
    opcopy();
    for(auto &x:so.clipBoard){
        cout<<x;
    }cout<<endl;
    noteInfo();
    cs.x=4,cs.y=2;
    opinsert("Paste");
    noteInfo();
    opprint();
    return 0;
}
*/

int main(){
    ios::sync_with_stdio(false);
    //file(data);
    cin>>n;
    string op;
    while(n--){
        //noteInfo();
        cin>>op;
        chOp(op);
    }
    return 0;
}


//https://blog.csdn.net/Flag_ing/article/details/123361432
/*
//v2.0
//a problem in freshing stringLineTail
#include <bits/stdc++.h>
using namespace std;
#define mem(f, v) memset(f,v,sizeof(f))
#define file(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);

//int supp;int todo;

typedef long long ll;
const int maxn = 5e3+3;
const int inf = ~(1u << 31u);
const ll linf = ~(1llu << 63u);
int n;//1,n,5e3
struct cursor{
    int x;
    int y;
}cs;
struct noteBook{
    string notes;
    deque<ll> stringLineTail;//note.note(note.lineTail.at(cs.x))
    noteBook(){}
    ll lineTail(int _x){return stringLineTail.at(_x-1);}
    ll lineHead(int _x){return _x>1?(stringLineTail.at(_x-2)+1):0;}
    int lineLen(int _x){return _x>1?(lineTail(_x-1)-lineTail(_x-2)):(lineTail(_x-1)+1);}
    ll lineAt(int _x,int _y){return lineHead(_x)+_y-1;}
}note;
struct shiftOthers{
    string clipBoard;//粘贴板
    bool shift;//粘滞功能
    bool selected;//选中状态
    cursor recordPoint;//记录点
    shiftOthers(string _clipBoard,bool _shift=false):clipBoard(_clipBoard),shift(_shift){}
}so;
void addLine(string s){
    todo;
}
void opmove(string op){
    if(op=="Home"){
        cs.y=1;
    }else if(op=="End"){
        cs.y=note.lineLen(cs.x)+1;
    }else if(op=="Up"){
        if(cs.x>1){
            int tmp=note.lineLen(--cs.x)+1;
            if(cs.y>tmp){
                cs.y=tmp;
            }
        }
    }else if(op=="Down"){
        if(cs.x<note.stringLineTail.size()){
            int tmp=note.lineLen(++cs.x)+1;
            if(cs.y>tmp){
                cs.y=tmp;
            }
        }
    }else if(op=="Left"){
        if(cs.y>1){
            --cs.y;
        }else if(cs.x>1){
            cs.y=note.lineLen(--cs.x)+1;
        }
    }else if(op=="Right"){
        if(cs.y<note.lineLen(cs.x)+1){
            ++cs.y;
        }else if(cs.x<note.stringLineTail.size()){
            cs.y=1;
            ++cs.x;
        }
    }
}
void opinsert(string op){
    if(op=="Char"){
        string c;
        cin>>c;
        note.notes.insert(note.stringLineTail.at(cs.x-1)+cs.y-1,c);
    }else if(op=="Enter"){
        note.stringLineTail.at(cs.x-1)=note.lineAt(cs.x,cs.y);
        note.stringLineTail.insert(note.stringLineTail.begin()+cs.x,note.lineTail(cs.x)+1);
        note.notes.insert(note.lineAt(cs.x,cs.y),"\n");
        ++cs.x;
        cs.y=1;
    }else if(op=="Space"){
        note.notes.insert(note.lineAt(cs.x,cs.y++)," ");
        ++note.stringLineTail.at(cs.x);
    }else if(op=="Paste"){
        todo;
    }
}
void opremove(string op){
    string s;
    cin>>s;
    if(s=="Del"){
        ll lineAt=note.lineAt(cs.x,cs.y);
        if(lineAt+1<note.notes.size()){
            if(note.notes[lineAt]=='\n'){//删的是换行符
                todo;
            }else{
                note.notes.erase(lineAt,1);
            }
        }
    }else if(s=="Backspace"){
        todo;
    }
}
void opshift(){
    if(so.shift){//粘滞功能关闭时
        if(so.recordPoint.x!=cs.x||so.recordPoint.y!=cs.y){//此时的光标位置与记录点的位置不同，进入选中状态
            bool flag=so.recordPoint.x<cs.x;
            int minx=flag?so.recordPoint.x:cs.x;
            so.selected=true;
        }
        so.shift=false;
    }else{//粘滞功能启动时
        so.recordPoint=cs;
        so.shift=true;
    }
}
void opfind(string word){
    int wordSize=word.size();
    ll cnt=0;
    if(so.selected){//当前处于选中状态
        ll sidec=note.lineAt(cs.x,cs.y);
        ll sides=note.lineAt(so.recordPoint.x,so.recordPoint.y);
        ll l=sidec<sides?sidec:sides;
        ll r=sidec>sides?sidec:sides;
        for(ll i=l;i<r;++i){
            if(word==note.notes.substr(i,wordSize)){
                ++cnt;
            }
        }
    }else{
        for(ll i=0;i<note.notes.size();++i){
            if(word==note.notes.substr(i,wordSize)){
                ++cnt;
            }
        }
    }
    cout<<cnt<<'\n';
}
void opcount(){
    ll cnt=0;
    int tmp=0;
    if(so.selected){
        ll sidec=note.lineAt(cs.x,cs.y);
        ll sides=note.lineAt(so.recordPoint.x,so.recordPoint.y);
        ll l=sidec<sides?sidec:sides;
        ll r=sidec>sides?sidec:sides;
        for(ll i=l;i<r;++i){
            tmp=note.notes[i]-'0';
            if(tmp>32&&tmp<127){
                ++cnt;
            }
        }
    }else{
        for(ll i=0;i<note.notes.size();++i){
            tmp=note.notes[i]-'0';
            if(tmp>32&&tmp<127){
                ++cnt;
            }
        }
    }
    cout<<cnt<<'\n';
}
void opcopy(){
    if(so.selected){
        ll sidec=note.lineAt(cs.x,cs.y);
        ll sides=note.lineAt(so.recordPoint.x,so.recordPoint.y);
        ll l=sidec<sides?sidec:sides;
        ll r=sidec>sides?sidec:sides;
        so.clipBoard=note.notes.substr(l,r-l);
    }else{
        int lineLen=note.lineLen(cs.x);
        if(lineLen>1){
            so.clipBoard=note.notes.substr(note.lineAt(cs.x,cs.y),lineLen-1);
        }
    }
}
void opprint(){
    cout<<note.notes<<'\n';
}

void chOp(string op){
    string s;
    if(op=="MOVE"){
        cin>>s;
        opmove(s);
    }else if(op=="INSERT"){
        cin>>s;
        opinsert(s);
    }else if(op=="REMOVE"){
        cin>>s;
        opremove(s);
    }else if(op=="SHIFT"){
        opshift();
    }else if(op=="FIND"){
        cin>>s;
        opfind(s);
    }else if(op=="COUNT"){
        opcount();
    }else if(op=="COPY"){
        opcopy();
    }else if(op=="PRINT"){
        opprint();
    }
}
int main(){
    ios::sync_with_stdio(false);
    //file(data);
    cin>>n;
    string op;
    while(n--){
        cin>>op;
        chOp(op);
    }
    return 0;
}
*/
/*
//v1.0
#include <bits/stdc++.h>
using namespace std;
#define mem(f, v) memset(f,v,sizeof(f))
#define file(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);

int supp;int todo;

typedef long long ll;
const int maxn = 5e3+3;
const int inf = ~(1u << 31u);
const ll linf = ~(1llu << 63u);
int n;//1,n,5e3
struct cursor{
    int x;
    int y;
}cs;
struct noteBook{
    vector<string> notes;
    map<int,int> mapping;//<noteLine,vsLine>
    int lines;
    int 
    noteBook(vector<string> _notes,int _lines=1):notes(_notes),lines(_lines){}
}note;
struct shiftOthers{
    string clipBoard;//粘贴板
    bool shift;//粘滞功能
    bool selected;//选中状态
    cursor recordPoint;//记录点
    shiftOthers(string _clipBoard,bool _shift=false):clipBoard(_clipBoard),shift(_shift){}
}so;
void addLine(string s){
    todo;
}
void opmove(string op){
    if(op=="Home"){
        cs.y=1;
    }else if(op=="End"){
        cs.y=note.notes[note.mapping[cs.x]].size()+1;
    }else if(op=="Up"){
        if(cs.x>1){
            int tmp=note.notes[note.mapping[--cs.x]].size()+1;
            cs.y=cs.y>tmp?cs.y:tmp;
        }
    }else if(op=="Down"){
        if(cs.x>1){
            int tmp=note.notes[note.mapping[++cs.x]].size()+1;
            cs.y=cs.y>tmp?cs.y:tmp;
        }
    }else if(op=="Left"){
        if(cs.y>1){
            --cs.y;
        }else if(cs.x>1){
            cs.y=note.notes[note.mapping[--cs.x]].size()+1;
        }
    }else if(op=="Right"){
        if(cs.y<note.notes[note.mapping[cs.x]].size()+1){
            ++cs.y;
        }else if(cs.x<note.lines){
            ++cs.x;
            cs.y=1;
        }
    }
}
void opinsert(string op){
    if(op=="Char"){
        string c;
        cin>>c;
        note.notes[note.mapping[cs.x]].insert(cs.y-1,c);
    }else if(op=="Enter"){
        note.notes[note.mapping[cs.x]]+='\n';
        addLine("\n");
    }else if(op=="Space"){
        note.notes[note.mapping[cs.x]].insert(cs.y-1," ");
    }else if(op=="Paste"){
        todo;
    }
}
void opremove(string op){
    string s;
    cin>>s;
    if(s=="Del"){
        todo;
    }else if(s=="Backspace"){
        todo;
    }
}
void opshift(){
    if(so.shift){//粘滞功能关闭时
        if(so.recordPoint.x!=cs.x||so.recordPoint.y!=cs.y){//此时的光标位置与记录点的位置不同，进入选中状态
            bool flag=so.recordPoint.x<cs.x;
            int minx=flag?so.recordPoint.x:cs.x;
            so.selected=true;
        }
        so.shift=false;
    }else{//粘滞功能启动时
        so.recordPoint=cs;
        so.shift=true;
    }
}
void opfind(string word){
    if(so.selected){//当前处于选中状态
        //
    }else{
        //
    }
}
void opcount(){}
void opcopy(){}
void opprint(){}

void chOp(string op){
    string s;
    if(op=="MOVE"){
        cin>>s;
        opmove(s);
    }else if(op=="INSERT"){
        cin>>s;
        opinsert(s);
    }else if(op=="REMOVE"){
        cin>>s;
        opremove(s);
    }else if(op=="SHIFT"){
        opshift();
    }else if(op=="FIND"){
        cin>>s;
        opfind(s);
    }else if(op=="COUNT"){
        opcount();
    }else if(op=="COPY"){
        opcopy();
    }else if(op=="PRINT"){
        opprint();
    }
}
int main(){
    ios::sync_with_stdio(false);
    //file(data);
    cin>>n;
    string op;
    while(n--){
        cin>>op;
        chOp(op);
    }
    return 0;
}
*/
